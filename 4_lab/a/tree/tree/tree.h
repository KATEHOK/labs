#pragma once


typedef struct Node {
	int key;
	char* pInfo;
	struct Node* pLeft;
	struct Node* pRight;
	struct Node* pParent;
	struct Node* pNext;
	// повторяющиеся ключи - в левом поддереве
} Node;

typedef struct Tree {
	Node* pRoot;
} Tree;

/*
* Инициализирует дерево.
* Вернет:
* NULL - отказ в выделении памяти;
* (Tree*) - указатель на созданное дерево.
*/
Tree* treeInit();

/*
* Инициализирует узел:
* (int) key - ключ;
* (char*) pInfo - информация (строка);
* (Node*) pNext - нить.
* Вернет:
* NULL - отказ в выделении памяти;
* (Node*) - указатель на созданный узел.
*/
Node* nodeInit(int key, char* pInfo, Node* pNext);

/*
* Вызывает рекурсивное удаление всех узлов дерева, удаляет дерево:
* (Tree*) pTree - указатель на дерево.
* Вернет:
* 0 - успешно;
* 1 - pTree == NULL.
*/
int treeDelete(Tree* pTree);

/*
* Рекурсивно удаляет все поддеревья узла и сам узел:
* (Node*) pNode - указатель на узел.
*/
void nodesDelete(Node* pNode);

/*
* Рекурсивно обходит дерево и печатает ключ и инфу узлов, ключ которых больше заданного:
* (Node*) pNode - указатель на узел;
* (int) keyStart - максимальный ключ, который не будет распечатан;
* (int) isKeyStartCorrect - если не равен нулю, печатает все дерево.
*/
void detour(Node* pNode, int keyStart, int isKeyStartCorrect);

/*
* Итерационно обходит дерево и печатает ключ и инфу узлов, ключ которых больше заданного:
* (Node*) pNode - указатель на узел;
* (int) keyStart - максимальный ключ, который не будет распечатан;
* (int) isKeyStartCorrect - если не равен нулю, печатает все дерево.
*/
void walk(Node* pNode, int keyStart, int isKeyStartCorrect);

/*
* Рекурсивно ищет узел по ключу и версии:
* (Node*) pNode - указатель на узел;
* (int) key - искомый ключ;
* (int) version - искомая версия (начинается с 1).
* Вернет:
* NULL - узел не найден;
* (Node*) - указатель на найденный узел.
*/
Node* search(Node* pNode, int key, int version);

/*
* Вызывает рекурсивный прямой обход дерева, начиная с определенного ключа:
* (Node*) pNode - указатель на узел;
* (int) keyStart - максимальный ключ, который не нужно обрабатывать;
* (int) isKeyStartCorrect - если 0, то не игнорирует keyStart, иначе - игнорирует.* 
*/
//void goDetour(Node* pNode, int keyStart, int isKeyStartCorrect);

/*
* НЕ ВСТАВЛЯЕТ В ПУСТОЕ ДЕРЕВО
* Всставляет новый узел (дублирующиеся ключи - в левое поддерево):
* (Node*) pNode - указатель на узел;
* (int) key - новый ключ;
* (char*) - информация (строка).
* Вернет:
* NULL - отказ в выделении памяти;
* (Node*) - указатель на созданный узел.
*/
Node* insertNotFirst(Node* pNode, int key, char* pInfo);

/*
* Ищет родительский элемент для нового ключа:
* (Node*) pNode - указатель на узел;
* (int) key - новый ключ;
* (int*) pLR - указатель, куда хаписать метку ребенка (0 - left, 1 - right).
* Вернет:
* (Node*) - искомый указатель.
*/
Node* searchFunnyFather(Node* pNode, int key, int* pLR);

/*
* Вставляет первый узел СТРОГО В ПУСТОЕ дерево:
* (Tree*) pTree - указатель на дерево;
* (int) key - ключ;
* (char*) pInfo - информация (строка).
* Вернет:
* NULL - отказ в выделении памяти;
* (Node*) - указатель на вставленный узел.
*/
Node* insertFirst(Tree* pTree, int key, char* pInfo);

/*
* Вызывает соответствующую функцию вставки:
* (Tree*) pTree - указатель на дерево;
* (int) key - ключ;
* (char*) pInfo - информация (строка).
* Вернет:
* NULL - отказ в выделении памяти;
* (Node*) - указатель на вставленный узел.
*/
Node* insert(Tree* pTree, int key, char* pInfo);

/*
* Вызывает в прямом порядке обход узлов с ключем, большим заданного:
* (Node*) pNode - указатель на узел;
* (int) key - максимальный ключ, который не нужно обходить. 
*/
//void callDetour(Node* pNode, int key);

/*
* Корректно удаляет узел по ключу:
* (Node*) pNode - указатель на поддерево, где находится целевой узел;
* (int) key - целевой ключ.
* Вернет:
* 0 - успешно;
* 1 - ключ не найден.
*/
int nodeDelete(Node* pNode, int key);

/*
* Рекурсивно ищет узел с максимальным ключом:
* (Node*) pNode - указатель на поддерево, в котором осуществляется поиск.
* Вернет:
* NULL - если pNode == NULL;
* (Node*) - указатель на искомый узел.
*/
Node* searchMax(Node* pNode);

/*
*/
Node* searchMaxOrEqual(Node* pNode, int key);

/*
* Рекурсивно ищет узел с минимальным ключом:
* (Node*) pNode - указатель на поддерево, в котором осуществляется поиск.
* Вернет:
* NULL - если pNode == NULL;
* (Node*) - указатель на искомый узел.
*/
Node* searchMin(Node* pNode);

/*
* Ищет узел указанной версии с максимально отличающимся ключом (приоритет минимальному значению):
* (Node*) pNode - указатель на поддерево, в котором нужно осуществить поиск;
* (int) key - ключ, от которого максимально должен отличаться ключ искомого узла;
* (int) version - версия ключа (от 0 до +oo).
* Вернет:
* NULL - pNode == NULL или указанной версии не существует;
* (Node*) - указатель на искомый узел.
*/
Node* searchSpecial(Node* pNode, int key, int version);

/*
* Считывает из текстового файла данные об дереве:
* (char*) pPath - путь до файла.
* Вернет:
* NULL - не успешно (не выделена память или не открыт файл);
* (Tree*) -указатель на новое дерево.
*/
Tree* download(char* pPath);

/*
* Рекурсивно печатает дерево "в виде дерева":
* (Node*) pNode - узел, с которого начать печать;
* (int) offset - количество пробелов перед текущим узлом (ставить 0).
*/
void printAsTree(Node* pNode, int offset);