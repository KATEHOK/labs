#pragma once

/*
* 
*    B
*   / \
*.........
*....R....
*.../ \...
*..B   B..
*./ \.....
*.........
* .../....
* .(B)....
* 
* +5th
*  
*/


typedef struct Info {
	char* pTxt;
	struct Info* pNext;
} Info;

typedef struct Node {
	unsigned int key;
	short color; //0 - black; 1 - red
	int infoCount;
	Info* pInfo;

	struct Node* pLeft;
	struct Node* pRight;
	struct Node* pParent;
} Node;

typedef struct Tree {
	Node* pRoot;
	Node* pEList;
} Tree;

/*
* Инициализирует дерево.
* Вернет:
* NULL - отказ в выделении памяти;
* (Tree*) - указатель на созданное дерево.
*/
Tree* treeInit();

/*
* Инициализирует узел дерева, окраска - RED:
* (Tree*) pTree - указатель на дерево;
* (int) key - ключ;
* (char*) pInfo - информация (строка).
* Вернет:
* NULL - отказ в выделении памяти;
* (Node*) - указатель на созданный узел.
*/
Node* nodeInit(Tree* pTree, int key, Info* pInfo);

/*
* Вызывает рекурсивное удаление всех узлов дерева, удаляет дерево:
* (Tree*) pTree - указатель на дерево.
*/
void treeDelete(Tree* pTree);

/*
* Рекурсивно удаляет все поддеревья текущего узла и сам текущий узел:
* (Node*) pNode - указатель на текущий узел;
* (Node*) pEList - указатель на лист.
*/
void nodesDelete(Node* pNode, Node* pEList);

/*
* Удаляет список информаций:
* (Info*) pInfo - указатель на элемент списка, с которого начинается удаление.
*/
void infoListDelete(Info* pInfo);

/*
* Рекурсивно обходит дерево и печатает ключ и инфу узлов, ключ которых не больше заданного:
* (Node*) pNode - указатель на узел;
* (Node*) pEList - указатель на лист;
* (int) keyEnd - максимальный ключ, который будет распечатан;
* (int) isKeyStartCorrect - если не равен нулю, печатает все дерево.
*/
void detour(Node* pNode, Node* pEList, int keyStart, int isKeyStartCorrect);

/*
* Рекурсивно ищет узел по ключу и версии:
* (Node*) pNode - указатель на узел;
* (Node*) pEList - указатель на лист;
* (int) key - искомый ключ;
* (int) version - искомая версия (начинается с 1)
* (Info**) ppInfo - указатель на указатель на информацию (если NULL, то инфа не запоминается);
* Вернет:
* NULL - узел не найден;
* (Node*) - указатель на найденный узел.
*/
Node* search(Node* pNode, Node* pEList, int key, int version, Info** ppInfo);

/*
* НЕ ВСТАВЛЯЕТ В ПУСТОЕ ДЕРЕВО
* Всставляет новый узел (дублирующиеся ключи - в список):
* (Tree*) pTree - указатель на дерево;
* (int) key - новый ключ;
* (char*) pTxt - информация (строка), данные из нее КОПИРУЮТСЯ.
* Вернет:
* NULL - отказ в выделении памяти или ошибка копирования;
* (Node*) - указатель на созданный узел.
*/
Node* insertNotFirst(Tree* pTree, int key, char* pTxt);

/*
* Ищет родительский элемент для нового ключа:
* (Node*) pNode - указатель на узел;
* (int) key - новый ключ;
* (int*) pLR - указатель, куда записать метку ребенка (-1 - возвращаемый ключ, 0 - left, 1 - right).
* Вернет:
* (Node*) - искомый указатель.
*/
Node* searchFunnyFather(Node* pNode, int key, int* pLR);

/*
* Вставляет первый узел СТРОГО В ПУСТОЕ дерево:
* (Tree*) pTree - указатель на дерево;
* (int) key - ключ;
* (char*) pTxt - информация (строка), данные из нее КОПИРУЮТСЯ.
* Вернет:
* NULL - отказ в выделении памяти или ошибка копирования функццией strcpy;
* (Node*) - указатель на вставленный узел.
*/
Node* insertFirst(Tree* pTree, int key, char* pTxt);

/*
* Инициализирует новый элемент спмска информации:
* (char*) pTxt - информация (строка), данные из нее КОПИРУЮТСЯ;
* (Info*) pNext - указатель на следующий элемент списка (для создания первого - NULL).
* Вернет:
* NULL - отказ в выделении памяти или ошибка копирования;
* (Info*) - указатель на новый элемент.
*/
Info* infoInit(char* pTxt, Info* pNext);

/*
* Вызывает соответствующую функцию вставки:
* (Tree*) pTree - указатель на дерево;
* (int) key - ключ;
* (char*) pInfo - информация (строка), данные из нее КОПИРУЮТСЯ.
* Вернет:
* NULL - отказ в выделении памяти или ошибка копирования;
* (Node*) - указатель на вставленный узел.
*/
Node* insert(Tree* pTree, int key, char* pTxt);

/*
* Левый поворот вокруг узла (против часовой стрелки):
* url = '5 Красно-черные деревья.pdf' (33);
* (Tree*) pTree - указатель на дерево;
* (Node*) pNode - указатель на узел 'А'.
*/
void rotateLeft(Tree* pTree, Node* pA);

/*
* Правый поворот вокруг узла (по часовой стрелке):
* url = '5 Красно-черные деревья.pdf' (36);
* (Tree*) pTree - указатель на дерево;
* (Node*) pNode - указатель на узел 'B'.
*/
void rotateRight(Tree* pTree, Node* pB);

/*
* Балансирует дерево после вставки оригинального ключа (не вызывается после первой вставки):
* (Tree*) pTree - указатель на дерево;
* (Node*) pNode - указатель на вставленный (корректируемый) элемент.
*/
void insertFix(Tree* pTree, Node* pNode);

//TO DO 

/*
* Корректно удаляет узел по ключу:
* (Node*) pNode - указатель на поддерево, где находится целевой узел;
* (int) key - целевой ключ.
* Вернет:
* 0 - успешно;
* 1 - ключ не найден.
*/
int nodeDelete(Node* pNode, int key);

/*
* Рекурсивно ищет узел с максимальным ключом:
* (Node*) pNode - указатель на поддерево, в котором осуществляется поиск.
* Вернет:
* NULL - если pNode == NULL;
* (Node*) - указатель на искомый узел.
*/
Node* searchMax(Node* pNode);

/*
*/
Node* searchMaxOrEqual(Node* pNode, int key);

/*
* Рекурсивно ищет узел с минимальным ключом:
* (Node*) pNode - указатель на поддерево, в котором осуществляется поиск.
* Вернет:
* NULL - если pNode == NULL;
* (Node*) - указатель на искомый узел.
*/
Node* searchMin(Node* pNode);

/*
* Ищет узел указанной версии с максимально отличающимся ключом (приоритет минимальному значению):
* (Node*) pNode - указатель на поддерево, в котором нужно осуществить поиск;
* (int) key - ключ, от которого максимально должен отличаться ключ искомого узла;
* (int) version - версия ключа (от 0 до +oo).
* Вернет:
* NULL - pNode == NULL или указанной версии не существует;
* (Node*) - указатель на искомый узел.
*/
Node* searchSpecial(Node* pNode, int key, int version);

/*
* Считывает из текстового файла данные об дереве:
* (char*) pPath - путь до файла.
* Вернет:
* NULL - не успешно (не выделена память или не открыт файл);
* (Tree*) -указатель на новое дерево.
*/
Tree* download(char* pPath);

/*
* Рекурсивно печатает дерево "в виде дерева":
* (Node*) pNode - узел, с которого начать печать;
* (int) offset - количество пробелов перед текущим узлом (ставить 0).
*/
void printAsTree(Node* pNode, int offset);